{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home What is the Shader Compendium? The Shader Compendium is an attempt to unify tons of functions that are commonly used to write shaders. This includes snippets of code for distance functions, SDF operators, lighting models, rendering algorithms, color functions, and many other small utility functions. What about licensing? Every snippet of code will have the original author and their chosen license included. Contribute? I'd love if you would like to contribute, simply create a pull request on GitHub, and I'll gladly add it! Test \\[ ax^2 + bx + c\\]","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#what-is-the-shader-compendium","text":"The Shader Compendium is an attempt to unify tons of functions that are commonly used to write shaders. This includes snippets of code for distance functions, SDF operators, lighting models, rendering algorithms, color functions, and many other small utility functions.","title":"What is the Shader Compendium?"},{"location":"#what-about-licensing","text":"Every snippet of code will have the original author and their chosen license included.","title":"What about licensing?"},{"location":"#contribute","text":"I'd love if you would like to contribute, simply create a pull request on GitHub, and I'll gladly add it!","title":"Contribute?"},{"location":"#test","text":"\\[ ax^2 + bx + c\\]","title":"Test"},{"location":"3d-sdf-shapes/","text":"3D SDF Shapes Sphere A sphere has a single parameter r , which is the radius of the sphere. 1 2 3 float sdSphere ( in vec3 p , float r ) { return length ( p ) - r ; } Author License Lars Rotgers Public Domain Box A box has three parameters, which are stored in a vec3 . These are used to define the width, length, and height of the box. 1 2 3 4 5 float sdBox ( vec3 p , vec3 b ) { vec3 q = abs ( p ) - b ; return length ( max ( q , 0.0 )) + min ( max ( q . x , max ( q . y , q . z )), 0.0 ); } Author License Inigo Quilez The MIT License Cylinder Credits https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm","title":"3D SDF Shapes"},{"location":"3d-sdf-shapes/#3d-sdf-shapes","text":"","title":"3D SDF Shapes"},{"location":"3d-sdf-shapes/#sphere","text":"A sphere has a single parameter r , which is the radius of the sphere. 1 2 3 float sdSphere ( in vec3 p , float r ) { return length ( p ) - r ; } Author License Lars Rotgers Public Domain","title":"Sphere"},{"location":"3d-sdf-shapes/#box","text":"A box has three parameters, which are stored in a vec3 . These are used to define the width, length, and height of the box. 1 2 3 4 5 float sdBox ( vec3 p , vec3 b ) { vec3 q = abs ( p ) - b ; return length ( max ( q , 0.0 )) + min ( max ( q . x , max ( q . y , q . z )), 0.0 ); } Author License Inigo Quilez The MIT License","title":"Box"},{"location":"3d-sdf-shapes/#cylinder","text":"","title":"Cylinder"},{"location":"3d-sdf-shapes/#credits","text":"https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm","title":"Credits"},{"location":"colors/","text":"Color functions HSV2RGB Image by https://doc.qt.io 1 2 3 4 5 vec3 hsv2rgb ( vec3 c ) { vec4 K = vec4 ( 1.0 , 2.0 / 3.0 , 1.0 / 3.0 , 3.0 ); vec3 p = abs ( fract ( c . xxx + K . xyz ) * 6.0 - K . www ); return c . z * mix ( K . xxx , clamp ( p - K . xxx , 0.0 , 1.0 ), c . y ); }","title":"Color functions"},{"location":"colors/#color-functions","text":"","title":"Color functions"},{"location":"colors/#hsv2rgb","text":"Image by https://doc.qt.io 1 2 3 4 5 vec3 hsv2rgb ( vec3 c ) { vec4 K = vec4 ( 1.0 , 2.0 / 3.0 , 1.0 / 3.0 , 3.0 ); vec3 p = abs ( fract ( c . xxx + K . xyz ) * 6.0 - K . www ); return c . z * mix ( K . xxx , clamp ( p - K . xxx , 0.0 , 1.0 ), c . y ); }","title":"HSV2RGB"},{"location":"lighting/","text":"Lighting models All the lighting models described on this page use the following notation, as illustrated in the image below. Source \u2014 Wikipedia Let \\(P\\) be the point on the surface, then: \\(\\mathbf{N}\\) is the normal vector of the surface at \\(\\mathbf{P\\mathbf{\\) . \\(\\mathbf{L}\\) is the vector from \\(\\mathbf{P}\\) to the light source. \\(\\mathbf{V}\\) is the vector from \\(\\mathbf{P}\\) to the camera (eye). \\(\\mathbf{H}\\) is the halfway vector between \\(\\mathbf{L}\\) and \\(\\mathbf{V}\\) . \\(\\mathbf{R}\\) is the reflected vector \\(\\mathbf{V}\\) around \\(\\mathbf{N}\\) . To find the reflection vector, we can use \\(\\mathbf{R} = \\mathbf{V} - 2(\\mathbf{V}\\cdot\\mathbf{N})\\mathbf{N}\\) , where \\(\\mathbf{V}\\cdot\\mathbf{N}\\) is a dot-product. To find the halfway vector, we can use \\(\\mathbf{H} = \\dfrac{\\mathbf{L}+\\mathbf{V}}{||\\ \\mathbf{L}+\\mathbf{V}\\ ||}\\) . Attention Note that all of these vectors must be normalized, which is often denoted with a hat, like \\(\\mathbf{\\hat{N}}\\) . Lambertian Lambertian reflectance looks like an ideal \"matte\" or diffuse reflecting material. It is based on the angle between the light \\(\\mathbf{L}\\) and the surface normal \\(\\mathbf{N}\\) : \\[ I_D = \\mathbf{L}\\cdot\\mathbf{N}CI_L \\] where 1 2 3 4 float brdf_lambertian ( vec3 N , vec3 L ) { float k = clamp ( dot ( N , L ), 0. , 1. ); return k ; } Lambertian (wrapped) Wrapping the light can be used to fake subsurface scattering or area light. A parameter wrap is used which is a value between \\([0, 1]\\) . 1 2 3 4 5 float brdf_lambertian_wrapped ( vec3 N , vec3 L ) { float wrap = 0.5 ; float k = max ( 0. , ( dot ( L , N ) + wrap ) / ( 1. + wrap )); return k ; } Phong 1 2 3 4 float brdf_phong ( vec3 R , vec3 V , float exponent ) { float k = pow ( max ( 0. , dot ( R , V )), exponent ); return k ; } Blinn-Phong TBA Gaussian 1 2 3 4 5 6 float brdf_gaussian ( vec3 N , vec3 H , float m ) { float NHm = angle ( N , H ) / m ; float NHm2 = NHm * NHm ; float k = exp ( - NHm2 ); return k ; } Beckmann 1 2 3 4 5 6 7 8 9 10 float brdf_beckmann ( vec3 N , vec3 H , float m ) { float NdotH = dot ( N , H ); float tana = length ( cross ( N , H )) / NdotH ; float cosa = NdotH ; float m2 = m * m ; float tana2 = tana * tana ; float cosa4 = pow ( abs ( cosa ), 4. ); float k = exp ( - tana2 / m2 ) / ( 3.14159 * m2 * cosa4 ); return k ; } GGX The GGX lighting model is a microfacet model for refracting through rough surfaces. It is also a model that is becoming popular for lighting in video games. [1] The GGX lighting model is derived in this paper . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 float G1V ( float dotNV , float k ) { return 1.0 / ( dotNV * ( 1.0 - k ) + k ); } float brdf_ggx ( vec3 N , vec3 V , vec3 L , float roughness , float F0 ) { float alpha = roughness * roughness ; vec3 H = normalize ( V + L ); float dotNL = clamp ( dot ( N , L ), 0. , 1. ); float dotNV = clamp ( dot ( N , V ), 0. , 1. ); float dotNH = clamp ( dot ( N , H ), 0. , 1. ); float dotLH = clamp ( dot ( L , H ), 0. , 1. ); float alphaSqr = alpha * alpha ; float pi = 3.14159 ; float denom = dotNH * dotNH * ( alphaSqr - 1.0 ) + 1.0 ; float D = alphaSqr / ( pi * denom * denom ); float dotLH5 = pow ( 1.0 - dotLH , 5.0 ); float F = F0 + ( 1.0 - F0 ) * dotLH5 ; float k = alpha / 2.0 ; float vis = G1V ( dotNL , k ) * G1V ( dotNV , k ); return dotNL * D * F * vis ; } Author: John Hable Further Reading optimizing-ggx-shaders-with-dotlh/). * Physically Based Lighting at Pixar . * Physically Based Shading at Disney . * Real Shading in Unreal Engine 4 . References [1] [Optimizing GGX Shaders with dot(L,H)](http://filmicworlds.com/blog/","title":"Lighting models"},{"location":"lighting/#lighting-models","text":"All the lighting models described on this page use the following notation, as illustrated in the image below. Source \u2014 Wikipedia Let \\(P\\) be the point on the surface, then: \\(\\mathbf{N}\\) is the normal vector of the surface at \\(\\mathbf{P\\mathbf{\\) . \\(\\mathbf{L}\\) is the vector from \\(\\mathbf{P}\\) to the light source. \\(\\mathbf{V}\\) is the vector from \\(\\mathbf{P}\\) to the camera (eye). \\(\\mathbf{H}\\) is the halfway vector between \\(\\mathbf{L}\\) and \\(\\mathbf{V}\\) . \\(\\mathbf{R}\\) is the reflected vector \\(\\mathbf{V}\\) around \\(\\mathbf{N}\\) . To find the reflection vector, we can use \\(\\mathbf{R} = \\mathbf{V} - 2(\\mathbf{V}\\cdot\\mathbf{N})\\mathbf{N}\\) , where \\(\\mathbf{V}\\cdot\\mathbf{N}\\) is a dot-product. To find the halfway vector, we can use \\(\\mathbf{H} = \\dfrac{\\mathbf{L}+\\mathbf{V}}{||\\ \\mathbf{L}+\\mathbf{V}\\ ||}\\) . Attention Note that all of these vectors must be normalized, which is often denoted with a hat, like \\(\\mathbf{\\hat{N}}\\) .","title":"Lighting models"},{"location":"lighting/#lambertian","text":"Lambertian reflectance looks like an ideal \"matte\" or diffuse reflecting material. It is based on the angle between the light \\(\\mathbf{L}\\) and the surface normal \\(\\mathbf{N}\\) : \\[ I_D = \\mathbf{L}\\cdot\\mathbf{N}CI_L \\] where 1 2 3 4 float brdf_lambertian ( vec3 N , vec3 L ) { float k = clamp ( dot ( N , L ), 0. , 1. ); return k ; }","title":"Lambertian"},{"location":"lighting/#lambertian-wrapped","text":"Wrapping the light can be used to fake subsurface scattering or area light. A parameter wrap is used which is a value between \\([0, 1]\\) . 1 2 3 4 5 float brdf_lambertian_wrapped ( vec3 N , vec3 L ) { float wrap = 0.5 ; float k = max ( 0. , ( dot ( L , N ) + wrap ) / ( 1. + wrap )); return k ; }","title":"Lambertian (wrapped)"},{"location":"lighting/#phong","text":"1 2 3 4 float brdf_phong ( vec3 R , vec3 V , float exponent ) { float k = pow ( max ( 0. , dot ( R , V )), exponent ); return k ; }","title":"Phong"},{"location":"lighting/#blinn-phong","text":"TBA","title":"Blinn-Phong"},{"location":"lighting/#gaussian","text":"1 2 3 4 5 6 float brdf_gaussian ( vec3 N , vec3 H , float m ) { float NHm = angle ( N , H ) / m ; float NHm2 = NHm * NHm ; float k = exp ( - NHm2 ); return k ; }","title":"Gaussian"},{"location":"lighting/#beckmann","text":"1 2 3 4 5 6 7 8 9 10 float brdf_beckmann ( vec3 N , vec3 H , float m ) { float NdotH = dot ( N , H ); float tana = length ( cross ( N , H )) / NdotH ; float cosa = NdotH ; float m2 = m * m ; float tana2 = tana * tana ; float cosa4 = pow ( abs ( cosa ), 4. ); float k = exp ( - tana2 / m2 ) / ( 3.14159 * m2 * cosa4 ); return k ; }","title":"Beckmann"},{"location":"lighting/#ggx","text":"The GGX lighting model is a microfacet model for refracting through rough surfaces. It is also a model that is becoming popular for lighting in video games. [1] The GGX lighting model is derived in this paper . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 float G1V ( float dotNV , float k ) { return 1.0 / ( dotNV * ( 1.0 - k ) + k ); } float brdf_ggx ( vec3 N , vec3 V , vec3 L , float roughness , float F0 ) { float alpha = roughness * roughness ; vec3 H = normalize ( V + L ); float dotNL = clamp ( dot ( N , L ), 0. , 1. ); float dotNV = clamp ( dot ( N , V ), 0. , 1. ); float dotNH = clamp ( dot ( N , H ), 0. , 1. ); float dotLH = clamp ( dot ( L , H ), 0. , 1. ); float alphaSqr = alpha * alpha ; float pi = 3.14159 ; float denom = dotNH * dotNH * ( alphaSqr - 1.0 ) + 1.0 ; float D = alphaSqr / ( pi * denom * denom ); float dotLH5 = pow ( 1.0 - dotLH , 5.0 ); float F = F0 + ( 1.0 - F0 ) * dotLH5 ; float k = alpha / 2.0 ; float vis = G1V ( dotNL , k ) * G1V ( dotNV , k ); return dotNL * D * F * vis ; } Author: John Hable","title":"GGX"},{"location":"lighting/#further-reading","text":"optimizing-ggx-shaders-with-dotlh/). * Physically Based Lighting at Pixar . * Physically Based Shading at Disney . * Real Shading in Unreal Engine 4 .","title":"Further Reading"},{"location":"lighting/#references","text":"[1] [Optimizing GGX Shaders with dot(L,H)](http://filmicworlds.com/blog/","title":"References"},{"location":"math/","text":"Math functions Rotation matrix This will set up a 2D rotation matrix. It requires an angle a , and returns a mat2 . Multiply the vector with the matrix to rotate it. 1 2 3 4 mat2 rotate ( float a ) { float si = sin ( a ), co = cos ( a ); return mat2 ( co , si , - si , co ); } Info This 2D rotation matrix can also be used for 3D rotations. For example, to rotate on the Y-axis: 1 p . xz *= rotate ( angle ); Map This function will map \\(x\\) , with a range of \\([a, b]\\) , to the range \\([c, d]\\) . ```glsl float map(float x, float start1, float stop1, float start2, float stop2) { return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)); }","title":"Math functions"},{"location":"math/#math-functions","text":"","title":"Math functions"},{"location":"math/#rotation-matrix","text":"This will set up a 2D rotation matrix. It requires an angle a , and returns a mat2 . Multiply the vector with the matrix to rotate it. 1 2 3 4 mat2 rotate ( float a ) { float si = sin ( a ), co = cos ( a ); return mat2 ( co , si , - si , co ); } Info This 2D rotation matrix can also be used for 3D rotations. For example, to rotate on the Y-axis: 1 p . xz *= rotate ( angle );","title":"Rotation matrix"},{"location":"math/#map","text":"This function will map \\(x\\) , with a range of \\([a, b]\\) , to the range \\([c, d]\\) . ```glsl float map(float x, float start1, float stop1, float start2, float stop2) { return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)); }","title":"Map"},{"location":"rendering/","text":"Rendering Camera 1 2 3 4 5 6 vec3 ro = vec3 ( 0 , 0 , - 1. ); vec3 ta = vec3 ( 0 , 0 , 0 ); vec3 ww = normalize ( ta - ro ); vec3 uu = normalize ( cross ( ww , vec3 ( 0 , 1 , 0 ))); vec3 vv = normalize ( cross ( uu , ww )); vec3 rd = normalize ( uv . x * uu + uv . y * vv + 1.0 * ww ); Raymarcher Description A raymarching algorithm will intersect the scene by stepping a ray into the scene. At each step the distance, \\(d\\) , to the nearest object is calculated with a signed distance function, which is then used as the distance to safely step forward. An object is hit when the distance is smaller than some \\(\\epsilon\\) , for example: \\(d < 0.001\\) . This illustration visualizes this process. Image by https://adrianb.io The algorithm requires a ray origin ro , and a ray direction rd as input. The output of the algorithm is a value t , which is the distance from the origin to the intersection point. This intersection point \\(P\\) is then calculated with \\(P = \\textrm{ro} + t\\cdot \\textrm{rd}.\\) The algorithm has the following global parameters: Variable Description MIN_MARCH_DISTANCE The minimum distance to the object to qualify as a hit. Lower values will increase the detail, but slow down the algorithm. MAX_MARCH_DISTANCE The maximum distance that a ray is allowed to travel. Larger values will render the scene further, but slow down the algorithm. MAX_MARCH_STEP The maximum amount of steps the algorithm is allowed to take. Increase this if the detail between complex objects is poor. Higher values will slow down the algorithm. Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define MIN_MARCH_DIST 0.001 #define MAX_MARCH_DIST 20. #define MAX_MARCH_STEPS 60. float march ( in vec3 ro , in vec3 rd ) { float t = 0. ; float i = 0. ; for ( i = 0. ; i < MAX_MARCH_STEPS ; i ++ ) { vec3 p = ro + t * rd ; float d = map ( p ); if ( d < MIN_MARCH_DIST ) break ; t += d ; if ( t > MAX_MARCH_DIST ) break ; } if ( i >= MAX_MARCH_STEPS ) { t = MAX_MARCH_DIST ; } return t ; } See demo Info The algorithm requires a map(vec3 point) function (line 9), which is the output of a 3D SDF , for example: 1 2 3 float map ( vec3 p ) { return length ( p ) - 0.5 ; // Circle SDF } Credits Author License Lars Rotgers Public Domain Normals A normal vector is the vector \\(\\nabla f(\\mathbf{X})\\) . This can be calculated numerically with the central differences method. 1 2 3 4 5 6 7 vec3 normal ( in vec3 p ) { float eps = MIN_MARCH_DIST ; vec2 h = vec2 ( eps , 0 ); return normalize ( vec3 ( map ( p + h . xyy ) - map ( p - h . xyy ), map ( p + h . yxy ) - map ( p - h . yxy ), map ( p + h . yyx ) - map ( p - h . yyx ))); }","title":"Rendering"},{"location":"rendering/#rendering","text":"","title":"Rendering"},{"location":"rendering/#camera","text":"1 2 3 4 5 6 vec3 ro = vec3 ( 0 , 0 , - 1. ); vec3 ta = vec3 ( 0 , 0 , 0 ); vec3 ww = normalize ( ta - ro ); vec3 uu = normalize ( cross ( ww , vec3 ( 0 , 1 , 0 ))); vec3 vv = normalize ( cross ( uu , ww )); vec3 rd = normalize ( uv . x * uu + uv . y * vv + 1.0 * ww );","title":"Camera"},{"location":"rendering/#raymarcher","text":"","title":"Raymarcher"},{"location":"rendering/#description","text":"A raymarching algorithm will intersect the scene by stepping a ray into the scene. At each step the distance, \\(d\\) , to the nearest object is calculated with a signed distance function, which is then used as the distance to safely step forward. An object is hit when the distance is smaller than some \\(\\epsilon\\) , for example: \\(d < 0.001\\) . This illustration visualizes this process. Image by https://adrianb.io The algorithm requires a ray origin ro , and a ray direction rd as input. The output of the algorithm is a value t , which is the distance from the origin to the intersection point. This intersection point \\(P\\) is then calculated with \\(P = \\textrm{ro} + t\\cdot \\textrm{rd}.\\) The algorithm has the following global parameters: Variable Description MIN_MARCH_DISTANCE The minimum distance to the object to qualify as a hit. Lower values will increase the detail, but slow down the algorithm. MAX_MARCH_DISTANCE The maximum distance that a ray is allowed to travel. Larger values will render the scene further, but slow down the algorithm. MAX_MARCH_STEP The maximum amount of steps the algorithm is allowed to take. Increase this if the detail between complex objects is poor. Higher values will slow down the algorithm.","title":"Description"},{"location":"rendering/#code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #define MIN_MARCH_DIST 0.001 #define MAX_MARCH_DIST 20. #define MAX_MARCH_STEPS 60. float march ( in vec3 ro , in vec3 rd ) { float t = 0. ; float i = 0. ; for ( i = 0. ; i < MAX_MARCH_STEPS ; i ++ ) { vec3 p = ro + t * rd ; float d = map ( p ); if ( d < MIN_MARCH_DIST ) break ; t += d ; if ( t > MAX_MARCH_DIST ) break ; } if ( i >= MAX_MARCH_STEPS ) { t = MAX_MARCH_DIST ; } return t ; } See demo Info The algorithm requires a map(vec3 point) function (line 9), which is the output of a 3D SDF , for example: 1 2 3 float map ( vec3 p ) { return length ( p ) - 0.5 ; // Circle SDF }","title":"Code"},{"location":"rendering/#credits","text":"Author License Lars Rotgers Public Domain","title":"Credits"},{"location":"rendering/#normals","text":"A normal vector is the vector \\(\\nabla f(\\mathbf{X})\\) . This can be calculated numerically with the central differences method. 1 2 3 4 5 6 7 vec3 normal ( in vec3 p ) { float eps = MIN_MARCH_DIST ; vec2 h = vec2 ( eps , 0 ); return normalize ( vec3 ( map ( p + h . xyy ) - map ( p - h . xyy ), map ( p + h . yxy ) - map ( p - h . yxy ), map ( p + h . yyx ) - map ( p - h . yyx ))); }","title":"Normals"},{"location":"sdf-operators/","text":"SDF Operators https://www.shadertoy.com/view/Xs3GRB http://mercury.sexy/hg_sdf","title":"SDF Operators"},{"location":"sdf-operators/#sdf-operators","text":"https://www.shadertoy.com/view/Xs3GRB http://mercury.sexy/hg_sdf","title":"SDF Operators"}]}